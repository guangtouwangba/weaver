#!/usr/bin/env python3
"""
Unified Storage Manager for ArXiv Paper PDFs
Supports both local file system and Alibaba Cloud OSS storage backends.
"""

import os
import logging
import tempfile
import requests
from pathlib import Path
from typing import Optional, Dict, Any, Tuple
from datetime import datetime
import re

from .oss_client import create_oss_client

logger = logging.getLogger(__name__)

class StorageManager:
    """Unified storage manager supporting local and OSS backends"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize storage manager with configuration
        
        Args:
            config: Storage configuration dictionary
        """
        self.config = config
        self.backend = config.get('backend', 'local').lower()
        
        if self.backend not in ['local', 'oss']:
            raise ValueError(f"Unsupported storage backend: {self.backend}")
        
        # Initialize backend-specific components
        if self.backend == 'local':
            self._init_local_storage()
        elif self.backend == 'oss':
            self._init_oss_storage()
    
    def _init_local_storage(self):
        """Initialize local file system storage"""
        local_config = self.config.get('local', {})
        
        self.base_dir = Path(local_config.get('base_directory', './downloaded_papers'))
        self.create_subdirs = local_config.get('create_subdirectories', True)
        self.filename_format = local_config.get('filename_format', '{arxiv_id}.pdf')
        
        # Create base directory if it doesn't exist
        self.base_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Local storage initialized: {self.base_dir}")
    
    def _init_oss_storage(self):
        """Initialize OSS storage with fallback to local storage"""
        oss_config = self.config.get('oss', {})
        
        if not oss_config:
            logger.warning("OSS configuration missing, falling back to local storage")
            self._fallback_to_local()
            return
        
        try:
            self.oss_client = create_oss_client(oss_config)
            if not self.oss_client:
                logger.error("Failed to create OSS client, falling back to local storage")
                self._fallback_to_local()
                return
            
            self.create_subdirs = oss_config.get('create_subdirectories', True)
            self.filename_format = oss_config.get('filename_format', '{arxiv_id}.pdf')
            
            logger.info(f"OSS storage initialized: bucket={oss_config.get('bucket_name')}")
        except Exception as e:
            logger.error(f"OSS initialization failed: {e}, falling back to local storage")
            self._fallback_to_local()
    
    def _fallback_to_local(self):
        """Fallback to local storage when OSS fails"""
        logger.info("Falling back to local storage")
        self.backend = 'local'
        self._init_local_storage()
    
    def _safe_filename(self, text: str, max_length: int = 100) -> str:
        """Create a safe filename from text"""
        # Remove invalid characters
        safe = re.sub(r'[<>:"/\\|?*]', '', text)
        # Replace spaces with underscores
        safe = re.sub(r'\s+', '_', safe)
        # Limit length
        if len(safe) > max_length:
            safe = safe[:max_length]
        return safe
    
    def _get_storage_path(self, paper) -> str:
        """
        Generate storage path for a paper
        
        Args:
            paper: Paper object
            
        Returns:
            Storage path (local path or OSS key)
        """
        # Prepare variables for filename formatting
        format_vars = {
            'arxiv_id': paper.arxiv_id,
            'title_safe': self._safe_filename(paper.title),
            'date': paper.published.strftime('%Y-%m-%d')
        }
        
        filename = self.filename_format.format(**format_vars)
        
        if self.backend == 'local':
            if self.create_subdirs:
                subdir = self.base_dir / paper.published.strftime('%Y-%m-%d')
                subdir.mkdir(parents=True, exist_ok=True)
                return str(subdir / filename)
            else:
                return str(self.base_dir / filename)
        
        elif self.backend == 'oss':
            # For OSS, return the object key (will be generated by OSS client)
            return self.oss_client._generate_object_key(paper.arxiv_id, paper.published)
    
    def download_and_store_pdf(self, paper, timeout: int = 300) -> Tuple[bool, Optional[str]]:
        """
        Download PDF and store it using the configured backend
        
        Args:
            paper: Paper object with pdf_url
            timeout: Download timeout in seconds
            
        Returns:
            Tuple of (success: bool, storage_path: Optional[str])
        """
        if not paper.pdf_url:
            logger.error(f"No PDF URL for paper {paper.arxiv_id}")
            return False, None
        
        storage_path = self._get_storage_path(paper)
        
        # Check if file already exists
        if self.file_exists(storage_path):
            logger.info(f"PDF already exists: {storage_path}")
            return True, storage_path
        
        try:
            logger.info(f"Downloading PDF for {paper.arxiv_id}: {paper.title}")
            
            # Download PDF to temporary file first
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as temp_file:
                temp_path = temp_file.name
                
                # Download PDF
                response = requests.get(paper.pdf_url, timeout=timeout, stream=True)
                response.raise_for_status()
                
                # Write to temporary file
                for chunk in response.iter_content(chunk_size=8192):
                    temp_file.write(chunk)
            
            # Store using appropriate backend
            if self.backend == 'local':
                success, final_path = self._store_local(temp_path, storage_path)
            else:  # OSS
                success, final_path = self._store_oss(temp_path, paper)
            
            # Clean up temporary file
            try:
                os.unlink(temp_path)
            except:
                pass
            
            if success:
                logger.info(f"PDF stored successfully: {final_path}")
                return True, final_path
            else:
                logger.error(f"Failed to store PDF for {paper.arxiv_id}")
                return False, None
                
        except Exception as e:
            logger.error(f"Error downloading/storing PDF for {paper.arxiv_id}: {e}")
            return False, None
    
    def _store_local(self, temp_path: str, target_path: str) -> Tuple[bool, Optional[str]]:
        """Store file in local file system"""
        try:
            # Ensure target directory exists
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            
            # Move file from temp to target location
            import shutil
            shutil.move(temp_path, target_path)
            
            return True, target_path
        except Exception as e:
            logger.error(f"Failed to store file locally: {e}")
            return False, None
    
    def _store_oss(self, temp_path: str, paper) -> Tuple[bool, Optional[str]]:
        """Store file in OSS"""
        try:
            object_key = self.oss_client.upload_file(temp_path, paper.arxiv_id, paper.published)
            return True, object_key
        except Exception as e:
            logger.error(f"Failed to store file in OSS: {e}")
            return False, None
    
    def file_exists(self, storage_path: str) -> bool:
        """
        Check if file exists in storage
        
        Args:
            storage_path: Path to check (local path or OSS key)
            
        Returns:
            True if file exists, False otherwise
        """
        if self.backend == 'local':
            return os.path.exists(storage_path)
        else:  # OSS
            return self.oss_client.object_exists(storage_path)
    
    def get_file_url(self, storage_path: str, expires: int = 3600) -> Optional[str]:
        """
        Get URL for accessing stored file
        
        Args:
            storage_path: Path to file (local path or OSS key)
            expires: URL expiration time in seconds (OSS only)
            
        Returns:
            File URL or None if error
        """
        if self.backend == 'local':
            # For local files, return file:// URL
            return f"file://{os.path.abspath(storage_path)}"
        else:  # OSS
            return self.oss_client.get_object_url(storage_path, expires)
    
    def delete_file(self, storage_path: str) -> bool:
        """
        Delete file from storage
        
        Args:
            storage_path: Path to file (local path or OSS key)
            
        Returns:
            True if successful, False otherwise
        """
        if self.backend == 'local':
            try:
                os.remove(storage_path)
                return True
            except Exception as e:
                logger.error(f"Failed to delete local file {storage_path}: {e}")
                return False
        else:  # OSS
            return self.oss_client.delete_object(storage_path)
    
    def get_storage_info(self) -> Dict[str, Any]:
        """
        Get storage backend information
        
        Returns:
            Dictionary with storage information
        """
        info = {
            'backend': self.backend,
            'create_subdirectories': self.create_subdirs,
            'filename_format': self.filename_format
        }
        
        if self.backend == 'local':
            info.update({
                'base_directory': str(self.base_dir),
                'exists': self.base_dir.exists()
            })
        else:  # OSS
            info.update(self.oss_client.get_bucket_info())
        
        return info

def create_storage_manager(config: Dict[str, Any]) -> StorageManager:
    """
    Create storage manager from configuration
    
    Args:
        config: Storage configuration dictionary
        
    Returns:
        StorageManager instance
    """
    return StorageManager(config)